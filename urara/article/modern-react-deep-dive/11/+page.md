---
title: '11장 Next.js 13과 리액트 18'
created: 2024-05-21 12:00
updated: 2024-05-21 12:00
tags:
- 'Frontend'
- 'Study'
- 'Book'
---

# 중요한 부분 정리

## app 디렉터리의 등장

13버전 이전까지는 모든 페이지는 가각 구별된 파일로 독립되어 있었다.
페이지를 공통으로 무언가를 집어넣을 수 있는 곳은 `_document`, `_app`이 유일하다.
- _document: 페이지에서 쓰이는, 태그를 수정하거나 서버 사이드 렌더링 시 `styled-components`와 같은 일부 CSS-in-JS를 지원하기 위한 코드를 삽입하는 제한적인 용도로 사용.
- _app: 페이지를 초기화하기 위한 용도로 사용되며 다음과 같은 작업이 가능
    - 페이지 변경 시에 유지하고 싶은 레이아웃
    - 페이지 변경 시 상태 유지
    - componentDidCatch를 활용한 에러 핸들링
    - 페이지간 추가적인 데이터 삽입
    - global CSS 주입

이전의 12버전까지는 페이지 공통 레이아웃을 유지할 수 있는 방법은 `_app`이 유일했다. 이러한 레이아웃의 한계를 극복하기 위해 나온 것이 Next.js의 app 레이아웃이다.

### 라우팅

- 기존에 `/pages`로 정의하던 라우팅 방식이 `/app` 디렉터리로 이동
- 파일명으로 라우팅하는 것이 불가능해졌다. 파일명은 무시되고 폴더명까지만 주소로 변환된다.
- 즉, 13의 app 디렉터리 내부의 파일명은 라우팅 명칭에 아무런 영향을 미치지 못한다.


## 리액트 서버 컴포넌트

### 기존 리액트 컴포넌트와 서버 사이드 렌더링의 한계

- 자바스크립트 번들 크기가 0인 컴포넌트를 만들 수 없다.
- 백엔드 리소스에 대한 직접적인 접근이 불가능하다.
- 자동 코드 분할이 불가능하다.
- 연쇄적으로 발생하는 클라이언트와 서버의 요청을 대응하기 어렵다.
- 추상화에 드는 비용이 증가한다.

서버 컴포넌트는 위와 같은 한계점을 극복하기 위해 등장했다.

### 서버 컴포넌트란?

하나의 언어, 하나의 프레임워크, 그리고 하나의 API와 개념을 사용하면서 서버와 클라이언트 모두에서 컴포넌트를 렌더링할 수 있는 기법을 의미한다. 서버에서 할 수 있는 일은 서버가 처리하게 두고, 서버가 할 수 없는 나머지 작업은 클라이언트인 브라우저엣에 수행된다.

> 주의해야할 점은 서버컴포넌트는 요청이 오면 그 순간 서버에서 딱 한 번 실행될 뿐ㅇ니므로 상태를 가질 수 없다. 그 말인 즉슨 useState, useReducer와 같은 리액트 생명주기 메서드나 훅을 사용할 수 없다는 뜻이다.

### 서버 컴포넌트는 어떻게 작동하는가?

1. 서버가 렌더링 요청을 한다.
    - 서버가 렌더링 과정을 수행해야 하므로 리액트 서버 컴포넌트를 사용하는 모든 페이지는 서버에서 시작된다.
    - 루트에 있는 컴포넌트는 항상 서버 컴포넌트다.
2. 서버는 받은 요청에 따라 컴포넌트를 JSON으로 직렬화한다.
    - 서버에서 렌더링할 수 있는 것은 직렬화해서 내보내고, 클라이언트 컴포넌트로 표시된 부분은 해당 공간을 플레이스홀더 형식으로 비워두고 나타낸다.
    - 브라우저는 이후에 이 결과물을 받아서 다시 역직렬화한 다음 렌더링을 수행한다
3. 브라우저가 컴포넌트 트리를 구성한다.
    - 트리를 구성했다면 구성한 트리를 바탕으로 렌더링해 브라우저의 DOM에 커밋한다.


## Next.js에서의 리액트 서버 컴포넌트

- Next.js의 루트 컴포넌트는 각 페이지에 존재하는 page.js이고, 루트 컴포넌트는 무조건 서버 컴포넌트가 된다.
- layout.js도 마찬가지로 서버 컴포넌트로 작동한다.

### 새로운 fetch 도입과 getServerSideProps, getStaticProps, getInitialProps의 삭제

- 과거 Next.js의 서버 사이드 렌더링과 정적 페이지를 제공을 위해 getServerSideProps, getStaticProps, getInitialProps가 `/app` 디렉터리 내부에서 삭제됐다.
- 그 대신 모든 데이터 요청은 웹에서 제공하는 표준 API인 `fetch`를 기반으로 이뤄진다.

### 정적 렌더링과 동적 렌더링

- 정적 라우팅에 대해서는 기본적으로 빌드 타임에 렌더링을 미리 해두고 캐싱해서 재사용할 수 있게끔 해두었다.
- 동적 라우팅에 대해서는 서버에 매번 요청이 올 때 마다 컴포넌트를 렌더링하도록 변경했다.

### 캐시와 mutating, 그리고 revalidating

- `fetch`의 기본 작동을 재정의해 `{next: {revalidate?: number | false}}`를 제공하는데, 이를 바탕으로 해당 데이터의 유효한 시간을 정해두고 이 시간이 지나면 다시 데이터를 불러와서 페이지를 렌더링하는 것이 가능하다.

### 스트리밍을 활용한 점진적인 페이지 불러오기

- 과거 서버 사이드 렌더링은 페이지가 다 불러와질 때까지 사용자는 빈화면을 보게 됐었다.
- 이를 해결하기 위해 하나의 페이지가 다 완성될 때까지 기다리는 것이 아니라 HTML을 작은 단위로 쪼개서 완성되는 대로 클라이언트로 점진적으로 보내는 스트리밍이 도입됐다.
- 스트리밍을 활용하면 모든 데이터가 로드될 때까지 기다리지 않더라도 먼저 데이터가 로드되는 컴포넌트를 빠르게 보여주는 방법이 가능하다.

## 웹팩의 대항마, 터보팩의 등장(beta)

## 서버 액션(alpha)

## 그 밖의 변화

## Next.js 13 코드 맛보기

## 정리 및 주의사항

## 참고자료

- https://www.joshwcomeau.com/react/server-components/

# 회고

## Liked(좋았던 점)

-

## Learned(배웠던 점)

-

## Lacked(아쉬운 점)

-

## Longed for(개선점)

- 
