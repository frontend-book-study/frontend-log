---
title: '2장 리액트 핵심 요소 깊게 살펴보기'
created: 2024-04-09
updated: 2024-04-09
tags:
  - 'Frontend'
  - 'Study'
  - 'Book'
---

# 중요한 부분 정리

## 1. JSX란?

- JSX가 리액트의 전유물이라고 오해하는 경우가 있다. 이는 반은 맞고 반은 틀리다.
- JSX는 개발자들이 알고 있는 XML과 유사한 내장형 구문이며, 리액트에 종속적이지 않은 독자적인 문법으로 보는 것이 맞다.
- JSX는 자바스크립트 내부에서 표현하기 까다로웠던 XML 스타일의 트리 구문을 작성하는 데 많은 도움을 주는 새로운 문법이라고 볼 수 있다.
- JSX의 설계 목적은 다양한 트랜스파일러에서 다양한 속성을 가진 트리 구조를 토큰화해 ECMAScript로 변환하는 데 초점을 두고 있다.
- `JSXElement`를 첫 번째 인수로 선언해 요소를 정의하고 옵셔널인 `JSXChildren, JSXAttributes, JSXStrings`는 이후 인수로 넘겨서 처리한다. 이 점을 활용한다면 경우에 따라 다른 `JSXElement`를 렌더링해야 할 때 굳이 요소 전체를 감싸지 않더라도 처리할 수 있다.

```jsx
// props 여부에 따라 children 요소만 달라지는 경우 코드 중복이 일어난다.
return isHeading ? (
    <h1>{childern}</h1>
) : (
    <div>{children}</div>
)

// JSX가 변환되는 특성을 활용한다면 다음과 같이 간결하게 처리할 수 있다.
return createElemenet(
    isHeading ? 'h1' : 'div',
    { className: 'text' },
    children
)
```
- 컴포넌트명을 반드시 대문자로 사용해야 하는 이유?
    - 일반적으로 코드를 입력함에 있어 컴포넌트명을 대문자가 아닌 소문자로 입력할 시 오류 메시지를 볼 수 있는데,
      이는 리액트에서 HTML 태그명과 사용자가 만든 컴포넌트 태그명을 구분 짓기 위해서다.

## 2. 가상 DOM과 리액트 파이버

- DOM과 브라우저 렌더링 과정
    1. 브라우저가 사용자가 요청한 주소를 방문해 HTML 파일을 다운로드
    2. 브라우저 렌더링 엔진이 HTML을 파싱해 DOM 노드로 구성된 트리(DOM) 구성
    3. CSS 다운로드, 파싱해 CSS 트리(CSSOM) 구성
    4. DOM 노드 순회, 이 때 `display: none`과 같이 사용자 화면에서 보이지 않는 요소는 작업 X
    5. 눈에 보이는 노드를 대상으로 해당 노드에 대한 CSSOM 정보를 찾고 적용
        - `레이아웃(layout, reflow)`: 각 노드가 브라우저 화면의 어느 좌표에 나타내야 하는지 계산하는 과정
        - `페인팅(painting)`: 레이아웃 단계를 거친 노드에 색과 같은 실제 유효한 모습을 그리는 과정

> 리액트는 왜 가상 DOM을 사용할까?  
> 브라우저의 렌더링 과정 중 레이아웃과 페인팅 과정은 많은 비용이 드는 과정입니다.  
> 실제 DOM을 조작하여 어플리케이션을 개발한다면 DOM에 변경사항이 생길 때마다 여러번 리페인팅을 하는 비용이 든다.  
> 가상 DOM을 사용한다면 메모리에 변경사항을 저장하고 실제 변경에 대한 준비가 완료 되었을 때 실제 브라우저의 DOM에 변경하기 때문에 값비싼 과정을 여러번 거칠 필요가 없다.


- 리액트 파이버
    - 리액트 컴포넌트에 대한 정보를 1:1로 가지고 있는 것
    - `렌더단계`: 사용자에게 노출되지 않는 모든 비동기 작업을 수행함. 파이버의 작업, 우선순위를 지정하거나 중지시키거나 버리는 등의 작업이 일어남.
    - `커밋단계`: DOM에 실제 변경사항을 반영하기 위한 작업. commitWork()가 실행됨. 이 과정은 동기식으로 일어나고 중단될 수 없음. 처리하는 작업이 많아 화면에 불완전하게 표시될 수 있는 가능성이 높으므로, 이러한 작업을 메모리상에서 수행해(더블버퍼링) 최종 결과물만 실제 브라우저 DOM에 적용함.
    - "가급적이면 새로운 파이버를 생성하지 않는다": 반복적인 트리 비교&업데이트 작업 발생 => 이때마다 새롭게 파이버 JS 객체를 만드는 것은 리소스 낭비. 기존 객체를 재활용해 내부 속성값만 초기화 하거나 바꾸는 방식으로 트리 업데이트

- 리액트 파이버 트리
    - 리액트 내부에 2개 존재.
    - `current` 트리: 현재 모습을 담은 트리
    - `workInProgress` 트리: 작업 중인 상태를 나타내는 트리
    - 리액트 파이버 작업이 끝나면 단순히 포인터만 변경해 `workInProgress` 트리를 현재 트리로 바꿈. 이러한 기술을 **더블 버퍼링**이라고 함.
    - 미처 다 그리지 못한 모습(불완전한 트리)를 노출하지 않기 위해 더블 버퍼링을 사용. (커밋 단계에서 수행됨)
    - `current` 트리 기준으로 작업을 시작하고, 업데이트가 발생하면 `workInProgress` 트리를 빌드하기 시작. `workInProgress` 트리가 UI에 최종적으로 렌더링되어 반영 완료되면 `current`가 이 `workInProgress`로 변경됨.

- 파이버 재조정자(fiber reconciler)
    - 가상 DOM과 실제 DOM 을 비교해 변경사항 수집
    - 차이가 있으면, 변경에 관련된 정보를 가지고 있는 파이버를 기준으로 화면에 렌더링을 요청
    - `=>` **재조정(reconciliation)**: 리액트에서 어떤 부분을 새롭게 랜더링해야 하는지 가상 DOM과 실제 DOM을 비교하는 알고리즘
    - 스택조정자 `=>` 파이버로 구조 변경: 동시다발적인 이벤트와 애니메이션을 동기적으로 처리하면 지연이 생기기 때문에 비동기로 처리할 수 있는 알고리즘 개발
    - 파이버의 목표: 앱에서 발생하는 애니메이션, 레이아웃, 인터렉션에 올바른 결과물을 만드는 반응성 문제를 해결하는 것
    - 파이버는 컴포넌트가 최초로 마운트되는 시점에 생성해 이후에는 가급적이면 재사용


- 리액트와 리액트 네이티브의 렌더러가 서로 다르다 하더라도 내부적으로 파이버를 통해 조정되는 과정은 동일 => 동일한 재조정자를 사용할 수 있음.
- 가상 DOM과 리액트의 핵심은 브라우저의 DOM을 더욱 빠르게 그리고 반영하는 것이 아니라 바로 값으로 UI를 표현하는 것이다.
- 화면에 표시되는 UI를 자바스크립트의 문자열, 배열 등과 마찬가지로 값으로 관리하고 이러한 흐름을 효율적으로 관리하기 위한 매커니즘이 바로 리액트의 핵심이다.

## 3. 클래스형 컴포넌트와 함수형 컴포넌트

- 클래스 컴포넌트의 한계
    - 데이터의 흐름을 추적하기 어렵다.
    - 애플리케이션 내부 로직의 재사용이 어렵다.
    - 기능이 많아질수록 컴포넌트의 크기가 커진다.
    - 클래스는 함수에 비해 상대적으로 어렵다.
    - 코드 크기를 최적화하기 어렵다.
- `getDerivedStateFromError`, `componentDidCatch`, `getSnapshotBeforeUpdate`는 아직 리액트 훅으로 구현돼 있지 않기 때문에 세 가지 메서드가 필요한 경우 반드시 클래스형 컴포넌트를 사용해야 한다.
    - 일반적으로 앞의 두 메서드는 `ErrorBoundary`, 즉 에러 경계 컴포넌트를 만들기 위한 목적으로 많이 사용된다.
    - 이렇게 두 메서드를 사용한 클래스형 컴포넌트는 리액트 애플리케이션 전역에서 처리되지 않은 에러를 처리하기 위한 용도로 사용된다.

- Component vs PureComponent
    - Component는 state가 업데이트되는 대로 렌더링이 일어난다.
    - PureComponent는 state 값에 얕은 비교를 수행해 결과가 다를 때만 렌더링 한다.
- 함수형 컴포넌트 vs 클래스형 컴포넌트
    - 클래스형 컴포넌트의 생명주기 메서드가 함수형 컴포넌트에서는 존재하지 않는다.
    - 함수형 컴포넌트는 렌더링된 값을 고정하고(immutable), 클래스형 컴포넌트는 그렇지 못하다.(mutable)
        - setTimeout을 동일하게 사용할 경우: 클래스형 컴포넌트는 변경된 props를 기준으로, 함수형 컴포넌트는 클릭한 시점의 props를 기준으로 실행된다.

## 4. 렌더링은 어떻게 일어나는가?

- 브라우저의 렌더링: HTML과 CSS 리소스를 기반으로 웹페이지에 필요한 UI를 그리는 과정
- 리액트의 렌더링: 브라우저가 렌더링에 필요한 DOM 트리를 만드는 과정
    - 즉, 리액트 애플리케이션 트리 안에 있는 모든 컴포넌트들이 현재 자신들이 가지고 있는 props와 state값을 기반으로 어떤 DOM 결과를 제공할 것인지 제공하는 일련의 과정
- 렌더링은 시간과 리소스를 소비해 수행되는 과정이므로 렌더링 과정을 최소화해야함

- 렌더링은 언제 발생하는가?
    - 최초 렌더링
    - 리렌더링
        - 최초 렌더링이 발생한 이후로 발생하는 모든 렌더링
        - state 업데이트: 클래스 컴포넌트의 `setState` 실행, 함수 컴포넌트의 `useState()`의 setter 실행, 함수 컴포넌트의 `useReducer()`의 dispatch 실행
        - props 변경
        - 부모 컴포넌트의 렌더링
        - 클래스 컴포넌트의 forceUpdate 실행
        - 컴포넌트의 `key` props 변경

- 리액트의 렌더링은 총 두 단계로 분리되어 실행됨
    - 렌더 단계: 컴포넌트를 렌더링하고 변경 사항을 계산하는 모든 작업
    - 커밋 단계: 렌더 단계의 변경 사항을 실제 DOM에 적용해 사용자에게 보여주는 과정
- 리액트의 렌더링이 일어난다고 해서 무조건 DOM 업데이트가 일어나는 것은 아니다.
    - 렌더링 과정 중 첫 번째 단계인 렌더 단계에서 변경 사항을 감지할 수 없다면 커밋 단계가 생략되어 브라우저의 DOM 업데이트가 일어나지 않을 수 있다.
- 리액트에서 배열에 key가 필요한 이유
    - 리액트에서 key는 리렌더링이 발생하는 동안 형제 요소들 사이에서 동일한 요소를 식별하는 값이다. 리렌더링이 발생하면 current트리와 workInProgress트리 사이에서 어떠한 컴포넌트 변경이
      있었는지 구별해야하는데, 이때 구별하는 값이 바로 key다. key가 존재한다면 두 트리 사이에서 통일한 key를 가지고 있는 컴포넌트는 이를 기준으로 구별할 수 있지만, key가 없다면 단순히
      파이버 내부의 sibling 인덱스만을 기준으로 판단하게 된다. 이러한 변경사항을 구별하는 작업은 리렌더링이 필요한 컴포넌트를 최소화해야 하므로 반드시 필요한 작업이다.

## 5. 컴포넌트와 함수의 무거운 연산을 기억해 두는 메모이제이션

> 리액트 애플리케이션에서 할 수 있는 성능 최적화

### 주장1: 섣부른 최적화는 독이다. 꼭 필요한 곳에만 메모이제이션을 추가하자.

- 대부분의 가벼운 작업 자체는 메모이제이션해서 자바스크립트 메모리 어딘가에 두었다가 꺼내오는 것보다는 **매번 이 작업을 수행**해 결과를 반환하는 것이 더 빠를 수도 있다.

### 주장2: 렌더링 과정의 비용은 비싸다. 모조리 메모이제이션해 버리자.

- 리액트는 이전 렌더링 결과를 다음 렌더링과 구별하기 위해 저장해 둬야 한다. (재조정 알고리즘)
- 잘못된 memo로 지불하는 비용은 props에 대한 얕은 비교가 발생하면서 지불하는 비용일 뿐이다.

### 정리

- 실제 어느 지점에서 성능상 이점을 누릴 수 있는지 살펴보는 식으로 메모이제이션을 적용하는 것을 권장한다.
- 성능에 대해 깊게 연구해 볼 시간적 여유가 없는 상황이라면 일단 의심스러운 곳에는 먼저 적용할 것을 권장한다.

### 참고자료

- [리액트 컴파일러 관련 내용 있는 리액트 공식 블로그 아티클](https://react.dev/blog/2024/02/15/react-labs-what-we-have-been-working-on-february-2024)
- [D2:React 파이버 아키텍처 분석](https://d2.naver.com/helloworld/2690975)
- [간단한 리액트 만들어보기 튜토리얼](https://pomb.us/build-your-own-react/)

# 회고

## Keep (현재 만족하고 있는 부분)

- HackMD 편하네요
- 지난주에 비해 집중도가 올라간 것 같습니다.
- 지난주에 비해 읽어야 할 내용의 분량이 적절해서 시간 안에 정해진 내용을 다 읽을 수 있었음
- 1회독 후에 다시 복습하는 식으로 읽어서 수월하게 이해할 수 있었던 것 같습니다.
- 저번보다 마크다운 동기화가 잘 되서 편하게 작성했습니다~
- 시간이 부족할까봐 미리 주차 1회독을 하고 왔는데 시간이 적절했고 다회독인 만큼 이해가 더 잘되어 좋았습니다
- 제가 읽고 이해하고 있는 부분 이외에도 다른 분들의 의견을 들을 수 있어 좋았습니다

## Problem (개선이 필요한 부분)

- 내용 공유 시간을 조금 더 길게 가져가는건 어떨까요? 인상깊었던 부분 공유 뿐 아니라 오늘처럼 관련 아티클도 공유하고 모르는 부분도 질문하는 시간이 조금 더 있으면 좋을 것 같습니다!
- 분량을 2주차 기준으로 가져가도록 조절하는 게 좋겠습니다.

## Try (해결책)

- 10분 공유하기 30분 정리하기 -> 20분 공유하기 20분 정리하기
- 분량 조정하기
