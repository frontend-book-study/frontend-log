---
title: '1장 리액트 개발을 위해 꼭 알아야 할 자바스크립트'
created: 2024-04-02
updated: 2024-04-02
tags:
  - 'Frontend'
  - 'Study'
  - 'Book'
---

# 중요한 부분 정리

## 0. 들어가며

- 명시적인 상태 변경: 리액트는 단방향 바인딩만 지원한다. 이러한 리액트의 명시저상태 업데이트는 많은 개발자들에게 간단함과 유연함을 제공한다.
- 단점: 단방향 바인딩은 변화를 감지하고 업데이하는 코드를 작성해야 하며 코드의 규모가 증가한다.
- 장점: 비교적 배우기 쉽고 간결함, 강력한 커뮤니티

## 1. 자바스크립트의 동등 비교

- 리액트 컴포넌트의 랜더링이 일어나는 이유 중 하나가 바로 props의 동등 비교에 따른 결과다. 동등 비교는 객체의 얕은 비교를 기반으로 이루어진다.
- 원시 타입은 불변 형태의 값으로 저장된다.
- 객체는 원시 값과 다르게 변경 가능한 형태로 저장되며 값을 복사할 떼도 값이 아닌 참조를 전달하게 된다.
- 리액트에서 사용하는 동등 비교는 ==나 ===가 아닌 Object.is다. Object.is는 ES6에서 제공하는 기능이기 때문에 리액트에서는 이를 구현한 폴리필(Polyfill)을 함께 사용한다.
- 리액트에서 객체를 비교할 때에는 얕은 비교를 수행한다.

## 2. 함수

먼저 자바스크립트에서 함수는 일급 함수로 취급한다.

- 일급 함수란?
  변수에 함수 할당이 가능하다.
  함수에 인자로 전달이 가능하다.
  함수를 반환할 수 있다.

자바스크립트에서 함수를 정의는 방법은 4가지 방법이 존재한다.

- 함수 선언문
- 함수 표현식
- 함수 생성자
- 화살표 함수

각각의 정의 방법에는 조금씩 기술적인 차이가 존재한다.

- 함수 표현식과 선언 식의 차이
  함수 표현식과 선언 식의 가장 큰 차이는 호이스팅 여부이다.

> 호이스팅이란? 호이스팅은 자바스크립트 엔진이 코드를 실행하기 전에 미리 식별자들을 콜렉팅을 하는것을 뜻합니다(메모리에 등록). var 같은 경우에는 호이스팅 과정에서 undefined으로 초기화됩니다.

- 함수 생성자의 차이
  함수 생성자로 함수를 정의한다면, 클로저가 생성되지 않는다.

- 화살표 함수의 차이
  constructor를 사용할 수 없다.
  arguments가 존재하지 않는다.
  this 바인딩이 호출 시에 이루어지지 않고, 상위 스코프의 this를 그대로 따라간다.

## 3. 클래스

- 클래스는 자바스크립트의 프로토타입 기반으로 작동한다.
- 클래스 작동을 생성자 함수로 매우 유사하게 재현할 수 있다. 클래
- constuctor: 객체를 생성하는 데 사용하는 특수한 메서드. 하나만 존재할 수 있다.
- 프로퍼티: 인스턴스를 생성할 때 내부에 정의할 수 있는 속성값
- getter와 setter: `get firstCharacter() { ... }` 클래스에 값을 가져올 때 사용한다. `set  firstCharacter() { ... }` 클래스 필드에 값을 할당할 때 사용한다.
- 인스턴스 메서드: 클래스 내부에서 선언한 메서드. 프로토타입 메서드로 불리기도 한다.
- 정적 메서드: 클래스의 인스턴스가 아닌 이름으로 호출할 수 있는 메서드다. 클래스 자신을 가리키기 때문에 this를 사용할 수 없다.
- 상속: 상속받은 클래스를 기반으로 확장하는 개념이다.
- 프로토타입 체이닝: 직접 객체에서 선언하지 않았음에도 프로토타입에 있는 메서드를 찾아서 실행을 도와주는 것. 모든 객체는 프로토타입을 가지고 있음. 특정 속성을 찾을 때 자기 자신부터 최상위 객체인 Object까지 훑으며 메서드를 찾음.

## 4. 클로저

- 구조, 작동 방식, 훅의 원리, 의존성 배열 등 함수 컴포넌트 대부분의 기술이 클로저에 의존한다.
- 클로저: 함수와 함수가 선언된 어휘적 환경(Lexical Scope)의 조합
- 선언된 어휘적 환경: 변수가 코드 내부의 어디에서 선언되었는지
- 자바스크립트는 기본적으로 함수 레벨 스코프를 따른다. {} 블록이 스코프 범위를 결정하지 않는다.
- 리액트에서 클로저의 원리를 사용하고 있는 대표적인 것 중 하나가 `useState`이다.클로저는 생성될 때마다 해당 `Lexical Scope`를 기억해야 하므로 추가로 비용이 발생한다.
- 클로저 활용 장점: 전역 스코프의 사용을 막고, 개발자가 원하는 정보만 원하는 방향으로 노출 시킬 수 있음
- 클로저 활용 단점: 클로저 사용에는 비용이 든다<- 생성될 때마다 그 선언적 환경을 기억해야 하기 때문

## 5. 이벤트 루프와 비동기 통신의 이해

자바스크립트는 싱글 스레드 언어지만, 비동기적인 작업이 가능하데 이는 이벤트 루프의 도움이 있어서이다.

- 이벤트 루프는 하나의 마이크로 태스크 큐를 갖고 있는데, 기존의 태스크 큐와는 다른 태스크를 처리한다. 마이크로 태스크 큐는 기존 태스크 큐보다 우선권을 갖는다.

### 동기란?

직렬 방식의 작업 처리 방식으로, 요청이 시작된 이후에는 무조건 응답을 받은 이후에야 다른 작업을 처리할 수 있다. 이 때문에 한 번에 다양한 많은 작업을 처리할 수 없다.

### 비동기란?

벙렬 방식의 작업 처리 방식으로, 요청을 시작한 후 응답의 여부와 상관없이 다음 작업이 이루어지기 때문에 한 번에 여러 작업을 실행할 수 있다.

### 프로세스란?

프로그램을 구동해 프로그램의 상태가 메모리상에서 실행되는 작업 단위를 의미한다. 즉 하나의 프로그램 실행은 하나의 프로세스를 가지고 그 프로세스 내부에서 모든 작업이 처리되는 것을 의미한다. ### 스레드란?
하나의 프로세스에서는 여러 개의 스레드를 만들 수 있고 스레드끼리는 메모리를 공유하여 여러 작업을 동시에 수행할 수 있다.

### 자바스크립트의 스레드

자바스크립트는 싱글 스레드에서 작동하며, 동기 방식으로 작동한다. 즉, 자바스크립트의 코드의 실행이 하나의 스레드에서 순차적으로 이루어져, 코드가 한 줄 한 줄 실행되어 작업이 끝나기 전까지 뒤이은 작업이 실행되지 않는다.

- 자바스크립트는 싱글 스레드에서 작동하기 때문에, 한 번에 하나의 작업만 동기 방식으로만 처리할 수 있다.

- 프로세스: 프로그램을 구동해 프로그램 상태가 메모리 상에서 실행되는 작업 단위
- 스레드: 하나의 프로레스 내부에서 메모리를 공유하며 여러 가지 작업을 동시에 수행하는 더 작은 실행단위
- 자바스크립트의 싱글스레드만으로는 불가능한 비동기 이벤트 처리: 태스크 큐, 이벤트 루프, 마이크로 태스크 큐, 브라우저/Node.js API
- 자바스크립트 코드 실행은 싱글 스레드에서 이뤄지지만, 외부 Web API 등은 자바스크립트 코드 외부에서 실행되고 콜백이 태스크 큐로 들어감.
- 이벤트 루프는 호출 스택이 비고, 콜백이 실행 가능한 때가 오면 이것을 꺼내서 수행하는 역할.
- 태스크 큐: 실행해야 할 태스크의 집합. queue가 아닌 set 자료구조의 형태. <- 선택된 큐 중에 실행가능한(비동기 함수의 콜백함수, 이벤트 핸들러 등) 가장 오래된 태스크를 가져와야 하기 때문.
- 마이크로 테스크 큐는 기존 태스크큐보다 우선권을 가짐.
- 각 마이크로 테스크 큐를 실행한 뒤에 작업이 끝날때마다 한번씩 렌더링이 일어남.
- 동기코드, 마이크로 태스크 또한 렌더링에 영향을 미칠 수 있음 => 특정 렌더링이 무거운 작업과 연관이 있다면 분리 고려할 것

## 6. 리액트에서 자주 사용하는 자바스크립트 문법

- 객체 구조 분해 할당의 경우 트랜스파일을 거치면 번들링 크기가 상대적으로 크기 때문에 ES5를 고려해야 하고, 자주 사용하지 않는다면 꼭 써야 하는지 검토할 필요가 있다.
- 구조 분해 할당: 객체의 값을 말 그대로 해해 개별 변수에 할당하는 것. 배열 구조 분해 할당은 자유롭게 이름을 선언할 수 있기 때문에 useState는 배열을 반환하는 것으로 추측할 수 있다.
- 객체 초기자: `const obj = { a, b }`형식으로 축약해서 선언하는 것이 가능하다.
- 바벨: 자바스크립트의 최신 문법을 다양한 브라우저에서도 일관적으로 지원할 수 있도록 코드를 트랜스파일함.
- 객체구조분해할당, 객체전개연산자: 트랜스파일을 거치면 번들링 크기가 상대적으로 큼. 앱개발 환경이 ES5를 고려해야하고, 이 문법을 자주 쓰지 않는다면 꼭 써야하는지 검토할 필요 있음.
- Array.prototype.reduce: filter와 map의 조합이 훨씬 가독성이 좋지만, 같은 배열에 두 번 순환하는 문제가 있으므로 상황에 맞게 선택.
- Array.prototype.forEach: 실행되는 순간 에러를 던지거나 프로세스를 종료하지 않는 이상 순회를 멈출 수 없다.(break, return 해도 안됨) => 무조건 0(n)만큼 실행. 코드 작성과 실행시에 반드시 최적화 가능성 검토.

## 7. 선택이 아닌 필수, 타입스크립트

- 타입 체크를 정적으로 런타임이 아닌 빌드타임(트랜스파일) 타임에 수행할 수 있게 해준다.
- = 코드를 빌드하는 시점에 이미 에러가 발생할 가능성이 있는 코드를 확인할 수 있다.
- 타입가드 적극이용: instance of , tyeof, in
- 자바스크립트는 다른 언어에 비해 객체가 열려있는 구조로 만들어져있으므로 덕타이핑(duck typing)으로 객체를 비교해야 하는 특징이 있다.
- 덕타이팅: 객텡의 타입이 클래스의 상속, 인터페이스 구현 등으로 결정되는 것이 아니고 어떤 객체가 필요한
  변수와 메서드만 지니고 있다면 그냥 해당 타입에 속하도록 인정해주는 것ㄷ을
- 타입스크립트는 어디까지나 슈퍼셋 언어로, 타입스크립트의 모든 것이 자바스크립트 기반으로 작동한다.

# 회고

## Keep (현재 만족하고 있는 부분)

- 각자 중요하다고 생각하는 부분을 정리했기 때문에 내가 놓쳤던 부분을 다시 한 번 볼 수 있게 되어 좋았음.
- 혼자 읽었다면 1장을 2시간 안에 읽지 못했을 것 같음.
- 다른 사람들의 생각을 들으면서 다른 관점에서 바라볼 수 있게 되어 좋았습니다.
- 리액트만 사용하다보니 자바스크립트 개념을 얕게만 알고있었는데, 이번 기회로 자바스크립트를 조금 더 깊이 알 수 있었던 점이 좋았습니다.

## Problem (개선이 필요한 부분)

- 책으로만 읽다보니 예제 코드 같은 부분은 실제로 쳐보지는 못하고 뛰어넘게 된다.
- 분량이 꽤 있어서 주어진 시간에 모두 읽기 힘든 부분이 있다.
- 중요하지 않은 부분이라고 생각되면 읽기를 뛰어넘는 부분이 있었다.
- 처음에 들어가며 부분을 주의깊게 읽으면서 시간을 많이 썼다.
- 예상했던 것 보다 책읽는 시간이 오래 걸림.
- 분량이 많아서 시간안에 읽는게 생각보다 어려웠습니다.
- 정리를 어떤 식으로 하면 좋을지 틀이 있으면 좋을 것 같습니다!
- 정리하는 시간이 좀 더 길면 좋을 것 같아요!
- 생각보다 읽는데에 많은 시간이 소요되어서 읽는 시간을좀 더 늘렸으면 좋겠습니다.
- 예상보다 책을 읽는 데 시간이 오래 걸림. Live Share 딜레이 발생

## Try (해결책)

- Live Share 말고 다른 실시간 작성 툴 (노션 등) 생각해 보겠습니다.
- 책을 뛰어넘지 말고 속독하는 방법을 익혀야겠습니다.
- 시간 조정하기
  - 30분 읽기 5분 쉬기 30분 읽기 5분 쉬기 10분 공유하기 20분 정리하기 15분 회고
- 개인적으로 책을 더 읽어오는 거
- 예습이 필요할 것 같습니다.
- 어느 정도는 책을 읽어 오기? 다른 공동작업 툴 사용?
