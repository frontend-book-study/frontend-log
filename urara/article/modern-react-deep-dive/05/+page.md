---
title: '5장 리액트와 상태 관리 라이브러리'
created: 2024-04-23
updated: 2024-04-23
tags:
- '모던리액트DeepDive'
---

# 중요한 부분 정리

## 1. 상태 관리는 왜 필요한가?

- 웹 애플리케이션이 비대해지고 상태(데이터)도 많아짐에 따라 어디서 어떤 일이 일어나서 이 상태가 변했는지 등을 추적하고 이해하기가 매우 어려운 상황이었다.
- 페이스북 팀은 이러한 문제의 원인을 양방향 데이터 바인딩으로 봤다. 뷰(HTML)가 모델(자바스크립트)을 변경할 수 있으며, 반대의 경우도 모델도 뷰를 변경할 수 있다. 이는 코드를 작성하는 입장에서는 간단한 수 있지만 코드의 양이 많아지고 변경 시나리오가 복잡해질수록 관리가 어려워진다.
- 페이스북 팀은 양방향이 아닌 단방향으로 데이터 흐름을 변경하는 것을 제안하는데 이것이 바로 Flux 패턴의 시작이다.

### Flux 패턴

- `액션(action)` : 작업을 처리할 액션과 그 액션 발생 시 함께 포함시킬 데이터를 의미한다. 액션 타입과 데이터를 각각 정의해 dispatcher로 보낸다.
- `디스패처(dispatcher)` : 액션을 스토어에 보내는 역할을 한다.
- `스토어(store)` : 실제 상태에 따른 값과 상태를 변경할 수 있는 메서드를 가지고 있다.
- `뷰(view)` : 스토어에서 만들어진 데이터를 가져와 화면을 렌더링하는 역할을 한다. 또한 사용자의 입력이나 행위에 따라 상태를 업데이트하고자 할 때 액션을 호출한다.

### Context API와 useContext

- 리액트가 처음 세상에 나온 뒤에도 상태를 어떻게 적절하게 주입해야 하는지에 대한 고민은 계속 이어져왔다.
  - 부모에 있는 상태를 자식 컴포넌트에서 쓰기 위해서는 props를 끊임없이 인수로 넘겨야 하는 불편함이 있었다.
- 리액트 팀은 리액트 16.3에서 전역 상태를 하위 컴포넌트에 주입할 수 있는 새로운 Context API를 출시했다. props로 상태를 넘겨주지 않더라도 Context API를 사용하면 원하는 곳에서 Context Provider가 주입하는 상태를 사용할 수 있게 된 것이다.

### 훅의 탄생, 그리고 React Query와 SWR

- 리액트는 16.8 버전에서 함수형 컴포넌트에 사용할 수 있는 다양한 훅 API를 추가했다.
  - 이 훅 API는 기존에 무상태 컴포넌트를 선언하기 위해서만 제한적으로 사용됐던 함수형 컴포넌트가 클래스형 컴포넌트 이상의 인기를 구가할 수 있도록 많은 기능을 제공했다.
- 이러한 훅과 state의 등장으로 이전에는 볼 수 없던 방식의 상태 관리가 등장하는데 바로 React Query와 SWR이다.
  - 두 라이브러리는 모두 외부에서 데이터를 불러오는 fetch를 관리하는 데 특화된 라이브러리지만, API 호출에 대한 상태를 관리하고 있기 때문에 HTTP 요청에 특화된 상태 관리 라이브러리라 볼 수 있다.

### Recoil, Zustand, Jotai, Valtio에 이르기까지

- HTTP 요청에 특화된 상태 관리 라이브러리가 아닌 범용적인 상태 관리 라이브러리의 변화
  - 훅을 활용해 작은 크기의 상태를 효율적으로 관리함
  - Recoil, Jotai, Zustand, Valtio 모두 리액트 16.8 버전 이상을 요구하고 있음

## 2. 리액트 훅으로 시작하는 상태 관리

### 가장 기본적인 방법: useState와 useReducer

- useState의 등장으로 리액트에서는 여러 컴포넌트에 걸쳐 손쉽게 동일한 인터페이스의 상태를 생성하고 관리할 수 있게 됐다.
- 숫자를 1씩 증가시키는 useCounter라는 훅을 만들어 중복 로직 없이 훅으로 코드를 격리해 제공할 수 있다.
- useReducer 또한 마찬가지로 지역 상태를 관리할 수 있는 훅이다.
- 실제로 useState는 useReducer로 구현됐다.
- 여기서 useCounter 훅 안에서 지역 상태인 counter를 여러 컴포넌트가 동시에 사용할 수 있는 전역 상태(global state)로 만들어 컴포넌트가 사용하는 모든 훅이 동일한 값을 참조할 수 있게 하려면 어떻게 해야 할까?
  - 가장 먼저 떠오르는 방법은 상태를 컴포넌트 밖으로 끌어올리는 것이다.
- 두 훅은 재사용할 수 있는 지역 상태를 만들어 주지만 여러 컴포넌트에 걸쳐 공유하기 위해서는 컴포넌트 트리를 재설계하는 등의 수고로움이 필요하다.

### 지역 상태의 한계를 벗어나보자: useState의 상태를 바깥으로 분리하기

- 완전히 다른 곳에서 상태가 초기화되서 관리된다면 좋겠지만 리액트 환경에서는 작동하지 않는다. 컴포넌트가 리렌더링되지 않기 때문이다.
- 상태가 업데이트됐을 대 컴포넌트에 반영시키기 위한 리렌더링이 필요하다.
- 렌더링까지 자연스럽게 일어나려면 다음과 같은 조건을 만족해야 한다.

1. 컴포넌트 외부 어딘가에 상태를 두고 여러 컴포넌트가 같이 쓸 수 있어야 한다.
2. 외부 상태의 변화를 모든 컴포넌트는 알 수 있어야 하고 리렌더링이 일어나야 한다.
3. 상태가 객체인 경우 값이 변한다 하더라도 감지하는 값이 아니면 리렌더링이 발생해서는 안 된다.

- 조건을 만족할 수 있는 새로운 상태 관리 코드를 만들어 보자. store, callback, subscribe 함수가 필요하다.
- 요약하자면 createStore는 자신이 관리해야 하는 상태를 내부 변수로 가진 다음 get 함수로 해당 변수의 최신값을 제공하며, set 함수로 내부 변수를 최신화하며, 이 과정에서 등록된 콜백을 모조리 실행하는 구조를 띠고 있다.
- 마지막으로 createStore로 만들어진 store의 값을 참조하고, 이 값의 변화에 따라 컴포넌트를 렌더링을 유도할 사용자 정의 훅을 useStore로 만들어 작성한다.

### 상태 관리 라이브러리 Recoil, Jotai, Zustand 살펴보기

#### 페이스북이 만든 상태관리 라이브러리 Recoil

- 페이스북에서 만든 리액트를 위한 상태관리 라이브러리
- 최소 상태 개념인 Atom을 처음 리액트 생태계에 선보임
- 장점: 리액트에서 새롭게 만들어지는 기능을 잘 지원할 것으로 기대됨. 추가 미들웨어 필요 없이 비동기 지원. 자체 개발자도구 지원.
- 단점: 정식버전 1.0.0 릴리즈 시기 불확실. 호환성이 깨질 가능성이 있음.

#### Recoil에서 영감을 받은, 그러나 조금 더 유연한 Jotai

- Recoil의 Atom 모델에 영감을 받아 만들어진 상태관리 라이브러리
- 작은 단위의 상태를 위로 전파할 수 있는 구조: 상향식(bottom-up) 접근법
- 불필요한 리렌더링이 발생하지 않도록 설계(리액트 Context 문제점 해결 + 메모이제이션이나 최적화 하지 않아도 되도록)
- 간결한 api
- Recoil의 atom은 각 상태값이 모두 별도의 키를 필요로 해서 이걸 관리해야하는데, Jotai는 이 부분을 추상화해 관리함.(객체의 참조를 WeakMap에 보관해 별도의 문자열 키가 없이 관리 가능)
- atom만으로 atom의 파생된 상태를 만들 수 있음(Recoil은 파생된 값을 만들기 위해 selector가 필요함)

#### 작고 빠르며 확장에도 유연한 Zustand

- 리덕스에 영감을 받아 만들어졌다.
- 하나의 스토어를 중앙 집중형으로 활용해 스토어 내부에서 상태 관리
- `setState`: state 값을 변경하는 용도. partial과 replace로 나눠져 있다.
  - `partial`: state의 일부분만 변경하고 싶을 때 사용
  - `replace`: state를 완전히 새로운 값으로 변경하고 싶을 때 사용
- 어떤 프레임워크와는 별개로 완전히 독립적으로 구성
- `createStore`로 스토어를 만들 때 set이라는 인수를 활용해 생성할 수 있다.
- state를 생성할 때 setState, getState, api를 인수로 넘겨주기 때문에 가능하다.
- set을 통해 현재 스토어의 값을 재정의할 수도 있고, 두번째 인수로 get을 추가해 현재 스토어의 값을 받아올 수도 있다.
- `useStore`에서는 `useSyncExternalStoreWithSelector`를 사용해서 `useStore`의 `subscribe, getState`를 넘겨주고, 스토어에서 선택을 원하는 state를 고르는 함수인 selector를 넘겨준다.
  - `useSyncExternalStoreWithSelector`: useSyncExternalStore와 완전히 동일. 원하는 값을 가져올 수 있는 selector와 동등 비교를 할 수 있는 equalityFn 함수를 받는다
  - `useSyncExternalStore`: 리액트 18에서 만들어진 훅. 리액트 외부에서 관리되는 상태값을 리액트에서 사용할 수 있도록 도와준다.
- 장점: 특별히 많은 코드를 작성하지 않아도 빠르게 스토어를 만들고 사용할 수 있다. 라이브러리 크기가 Recoil(79.1kB) > Jotai(13.1kB), Zustand(2.9kB)로 차이난다. 미들웨어를 지원한다.


### 참고자료

- https://npmtrends.com/@xstate/react-vs-jotai-vs-mobx-vs-react-redux-vs-recoil-vs-redux-vs-zustand

# 회고

## Keep (현재 만족하고 있는 부분)

- 흥미로웠던 부분 공유하는 시간에서 공감대를 형성할 수 있어서 좋았습니다~
- 시간분배가 적절해서 좋았습니다.
- 오픈소스 현황과 추세를 공유할 수 있어서 좋았습니다.
- 리액트 개발 도구나 크롬 개발자 도구를 실제로 어떻게 활용하고 있는지 들을 수 있어 좋았습니다!
- 오늘도 분량이 적당해서 좋았습니다.
- 읽은 책 내용과 관련된 링크와 유용한 익스텐션 공유해주셔서 좋았습니다.
- 지난시간에 부득이하게 스터디에 참여하지 못했는데, 정리 내용과 채팅 내용이 남아있어 어떤 대화가 오갔는지 조금이나마 알 수 있어서 좋았습니다.

## Problem (개선이 필요한 부분)

- 만족스러워서 없습니다..
- 22

## Try (해결책)

- 기존 방식 유지
