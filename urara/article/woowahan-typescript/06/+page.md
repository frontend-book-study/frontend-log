---
title: '6주차: 8장.2 ~ 9장 훅 (268~305)'
created: 2024-08-07
updated: 2024-08-07
tags:
- '우아한타입스크립with리액트'
---

## 8.2 타입스크립트로 리액트 컴포넌트 만들기 ~ 8.3 정리(1)

#### Q


#### A


## 8.2 타입스크립트로 리액트 컴포넌트 만들기 ~ 8.3 정리(2)

#### Q


#### A


## 8.2 타입스크립트로 리액트 컴포넌트 만들기 ~ 8.3 정리(3)

#### Q


#### A


## 9.1 리액트 훅(1)

#### Q
Q1. useState에서 제네릭을 사용하여 얻을 수 있는 이점은 무엇이 있을까요? <br>
Q2. useEffect에서는 왜 비동기 함수를 호출할 수 없을까요? <br>
Q3. useRef는 자식 컴포넌트를 저장하는 변수로 활용할 수 있을 뿐만 아니라 다른 방식으로도 유용하게 사용 할 수 있습니다. 어떤 방식이 있을까요?

#### A
A1. 
- useState에서 제네릭을 통해 상태 변수의 타입을 명시적으로 지정할 수 있어, 이후 코드에서 발생할 타입 오류를 방지할 수 있습니다. <br><br>
- useState의 반환 튜플 두번째 요소인 Dispatch 타입 함수는 이전 상태 값을 받아 새로운 상태를 반환합니다. 제네릭을 통해 해당 Dispatch 타입 함수를 활용할 때 발생할 수 있는 예상치 못한 사이드 이펙트를 예방할 수 있습니다.

A2. 
- useEffect에서 비동기 함수를 호출 가능할 경우, 경쟁 상태를 불러일으킬 수 있기에 useEffect의 callback 함수에는 비동기 함수가 들어갈 수 없습니다.
- 경쟁상태란, 멀티스레딩 환경에서 동시에 여러 프로세스나 스레드가 공유된 자원에 접근하려고 할 때 발생할 수 있는 문제입니다. 이러한 상황에서 실행 순서나 타이밍을 예측할 수 없게 되어 프로그램 동작이 원하지 않는 방향으로 흐를 수 있습니다.

A3. 
- useRef로 관리되는 변수는 값이 바뀌어도 컴포넌트의 리렌더링이 발생하지 않습니다. 이런 특성을 활용해 불필요한 리렌더링을 피할 수 있습니다.
- useRef로 관리되는 변수는 값을 설정한 즉시 조회가 가능합니다.


## 9.1 리액트 훅(2)

#### Q


#### A


## 9.1 리액트 훅(3)

#### Q


#### A


## 9.2 커스텀 훅(1)

#### Q


#### A


## 9.2 커스텀 훅(2)

#### Q


#### A


## 9.2 커스텀 훅(3)

#### Q


#### A
