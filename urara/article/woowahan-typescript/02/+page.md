---
title: '2주차: 3장 고급 타입 (80~119)'
created: 2024-07-10
updated: 2024-07-10
tags:
  - '우아한타입스크립with리액트'
  - 'Frontend'
  - 'Study'
  - 'Book'
---


## 3.1 타입스크립트만의 독자적 타입 시스템

### any타입, unknown 타입, void 타입

#### Q

#### A

### never 타입, Array 타입, enum 타입

#### Q

#### A

## 3.2 타입 조합

### 교차 타입, 유니온 타입

#### Q

#### A

### 인덱스 시그니처, 인덱스 엑세스 타입

#### Q1. 인덱스 시그니처는 특정 타입의 속성 이름은 알 수 없지만, 속성값의 타입을 알고 있을 때 유용합니다 하지만 그만큼 한계점도 명확하게 존재하는데요 인덱스 시그니처의 한계점에는 무엇이 있을까요?
#### A1. 인덱스 시그니처를 선언할때는 다른 속성을 추가로 명시해 줄 수 있는데, 이때 추가로 명시된 속성이 인덱스 시그니처에 포함되는 타입이 아니면 에러가 발생합니다.

#### Q2.인덱스 엑세스 타입을 사용한 예시입니다 UserKeys에서 예상되는 타입을 답변해주세요
```
const user = { id: 1, name: 'John', age: 30 };
type UserKeys = keyof typeof user; // 예상되는 타입을 답변해주세요
```
#### A2.인덱스 엑세스 타입은 다른 타입의 특정 속성이 가지는 타입을 조회하기 위해 사용됩니다. 따라서 UserKeys의 타입은 "id" | "name" | "age" 입니다.

### 맵드 타입, 템플릿 리터럴 타입, 제네릭

#### Q

#### A

## 3.3 제네릭 사용법

### 함수의 제네릭, 호출 시그니처의 제네릭, 제네릭 클래스

#### Q

#### A

### 제한된 제네릭, 확장된 제네릭, 제네릭 예시

#### Q

#### A
